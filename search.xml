<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[nodejs实现替换项目内所有文件指定字段]]></title>
      <url>http://yoursite.com/2016/07/07/nodejs%E5%AE%9E%E7%8E%B0%E6%9B%BF%E6%8D%A2%E9%A1%B9%E7%9B%AE%E5%86%85%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5/</url>
      <content type="html"><![CDATA[<p>由于项目开发中项目的名称需要改变，需要将页面中出现旧名称的地方都替换成新的名称，包括一些提示语也要全部修改，想到现在需求经常改变，指不定哪天上头心血来潮就又改一次，而修改的工作肯定又落到我的头上，所以想到了写个脚本偷偷懒，提高一下效率。最近在学习nodejs，也正好熟悉一下fsapi。<br><a id="more"></a></p>
<h1 id="批量替换文件中的内容"><a href="#批量替换文件中的内容" class="headerlink" title="批量替换文件中的内容"></a>批量替换文件中的内容</h1><p>要开始一件从来没做过的事情，当然是先google一下。幸运的是找到了一个批量修改文件内URL的，正合我意，原始代买如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var arguments = process.argv.slice(2);</span><br><span class="line">var command = arguments[0]+&quot;&quot;;</span><br><span class="line">var newReplaceUrl = arguments[1]+&quot;&quot;;</span><br><span class="line"></span><br><span class="line">if(command != ‘-new‘ || newReplaceUrl == null)&#123;</span><br><span class="line">    throw ‘please input your new url. Eg: node rurl.js -new https://www.g.cn/‘;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">var fs = require(‘fs‘);</span><br><span class="line">var files = [&quot;bank.css&quot;, &quot;wallet.css&quot;];</span><br><span class="line">var URL_REG = /url\(.*?;/g;</span><br><span class="line">var PIC_REG = /url\(.*?(?=[A-Za-z_\-0-9]*(\.png|\.jpg))/;</span><br><span class="line"></span><br><span class="line">for(var i=0;i&lt;files.length;i++)&#123;</span><br><span class="line">    var file = files[i];</span><br><span class="line">    (function (_file)&#123;</span><br><span class="line">        fs.readFile(_file,function (err,data)&#123;</span><br><span class="line">            data = data + &quot;&quot;;</span><br><span class="line">            data = data.replace(URL_REG,function (word)&#123;</span><br><span class="line">                if(word.indexOf(&quot;important&quot;) != -1)&#123;</span><br><span class="line">                    return word;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    var url = &quot;url(&quot; + newReplaceUrl;</span><br><span class="line">                    return word.replace(PIC_REG, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            fs.writeFile(_file, data, function(err)&#123;</span><br><span class="line">                if(err)&#123;</span><br><span class="line">                    console.log(&quot;error!&quot; + _file);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    console.log(&quot;success!&quot; + _file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析了一下上面这段代码，其主要功能就是从命令行接受一个命令和一个新的url，然后打开files里面的每一个文件进行替换，而我的需求是从命令行接受两个参数，一个是旧的字符串，一个是新的字符串，然后将旧的字符串替换成新的。修改后代码为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var arguments = process.argv.slice(2); //从命令行获取需要替换的字段和新字段</span><br><span class="line">var oldstr = arguments[0]+&quot;&quot;;</span><br><span class="line">var newstr = arguments[1]+&quot;&quot;;</span><br><span class="line">var reg = new RegExp(oldstr, &apos;g&apos;); //要使用变量创建正则必须使用new RegEXP()，用字面量创建不行</span><br><span class="line">...</span><br><span class="line">data = data.replace(reg, newstr); //要全局替换的话replace里面必须使用正则，否则会只替换第一个匹配的字符串</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这样替换函数就修改完了，保存为replace.js。<br>替换函数写完之后，我新建了一个测试文件将文件路径写到replace里面，然后运行:</p>
<blockquote>
<p>node repalce.js 测试替换 测试成功</p>
</blockquote>
<p>打开测试文件发现里面测试替换的地方都变成测试成功了，说明替换函数没有问题。</p>
<h1 id="获取所有需要修改的路径并缓存起来"><a href="#获取所有需要修改的路径并缓存起来" class="headerlink" title="获取所有需要修改的路径并缓存起来"></a>获取所有需要修改的路径并缓存起来</h1><p>虽然替换函数写完之后，还面临着一个问题就是整个项目有几十个页面，手动添加的话肯定是不能满足我的，所以我又google了一下，nodejs如何遍历目录下所有文件，很快就找到前人写好的函数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;),  </span><br><span class="line">    fileList = [];</span><br><span class="line">function walk(path)&#123;  </span><br><span class="line">    var dirList = fs.readdirSync(path);</span><br><span class="line">    dirList.forEach(function(item)&#123;</span><br><span class="line">        if(fs.statSync(path + &apos;/&apos; + item).isDirectory())&#123;</span><br><span class="line">            walk(path + &apos;/&apos; + item);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            fileList.push(path + &apos;/&apos; + item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">walk(&apos;/dirName&apos;);</span><br><span class="line">console.log(fileList);</span><br></pre></td></tr></table></figure></p>
<p>恩，很简单的一个递归遍历，而且正好已经把路径存好了，但是运行函数需要手动修改根目录，查看了一下nodejs的api之后，发现获取当前路径的方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = fs.realpathSync(&apos;.&apos;);</span><br></pre></td></tr></table></figure></p>
<p>至此文件路径有了，替换函数有了，基本上已经完成了。但是我只需要找到特定后缀的文件进行修改，所以在遍历文件的时候加了一个判断，当后缀为.psp的时候才将路径缓存起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(/\.psp$/.test(item)) &#123; //将所有.psp后缀的文件路径保存在fileList中</span><br><span class="line">    fileList.push(path + &apos;/&apos; + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将replace.js放到项目的根目录下，然后运行</p>
<blockquote>
<p>node replace.js 老字符串  新字符串</p>
</blockquote>
<p>替换成功。以后终于不用再一个一个页面去改了。<br>完整版代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var current_path = fs.realpathSync(&apos;.&apos;); //获取当前路径 </span><br><span class="line">var fileList = [];</span><br><span class="line">var arguments = process.argv.slice(2); //从命令行获取需要替换的字段和新字段</span><br><span class="line">var oldstr = arguments[0]+&quot;&quot;;</span><br><span class="line">var newstr = arguments[1]+&quot;&quot;;</span><br><span class="line">var reg = new RegExp(oldstr, &apos;g&apos;); //新建替换正则</span><br><span class="line">console.log(oldstr + &apos;---&gt;&apos; + newstr)</span><br><span class="line"></span><br><span class="line">if(oldstr == null || newstr == null)&#123;</span><br><span class="line">    throw &apos;please input your oldstr and newstr: node replcae.js oldstr newstr&apos;;</span><br><span class="line">&#125;</span><br><span class="line">//获取当前文件夹内所有指定格式的文件的绝对路径并缓存起来</span><br><span class="line">function walk(path)&#123;  </span><br><span class="line">    var dirList = fs.readdirSync(path);</span><br><span class="line">    dirList.forEach(function(item)&#123;</span><br><span class="line">        if(fs.statSync(path + &apos;/&apos; + item).isDirectory())&#123;</span><br><span class="line">            walk(path + &apos;/&apos; + item);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(/\.psp$/.test(item)) &#123; //将所有.psp后缀的文件路径保存在fileList中</span><br><span class="line">                fileList.push(path + &apos;/&apos; + item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk(current_path);</span><br><span class="line">console.log(fileList);</span><br><span class="line"></span><br><span class="line">var files = fileList;</span><br><span class="line">for(var i=0;i&lt;files.length;i++)&#123;</span><br><span class="line">    var file = files[i];</span><br><span class="line">    (function (_file)&#123;</span><br><span class="line">        fs.readFile(_file,function (err,data)&#123;</span><br><span class="line">            data = data + &quot;&quot;;</span><br><span class="line">            data = data.replace(reg, newstr);</span><br><span class="line">            </span><br><span class="line">            fs.writeFile(_file, data, function(err)&#123;</span><br><span class="line">                if(err)&#123;</span><br><span class="line">                    console.log(&quot;error!&quot; + _file);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    console.log(_file + &apos;   ok!&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用webpack打包时常用的一些插件]]></title>
      <url>http://yoursite.com/2016/06/29/%E4%BD%BF%E7%94%A8webpack%E6%89%93%E5%8C%85%E6%97%B6%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>虽然之前已经看过很多webpack的教程，也动手写过一些小的测试用例来学习，但一直没有进行系统的记录，也没有对写过的东西进行系统化的整理，趁现在比较闲，开始整理一下webpack使用时一些通用的模块，同时构建好一个通用的开发目录，为以后开始新的项目的时候能够快速的进入开发，不必浪费时间在目录构建上面。</p>
<a id="more"></a>
<h1 id="初始化项目目录结构"><a href="#初始化项目目录结构" class="headerlink" title="初始化项目目录结构"></a>初始化项目目录结构</h1><p>新建项目主文件夹然后用git对项目进行管理</p>
<blockquote>
<p>mkdir  project<br>git init</p>
</blockquote>
<h1 id="webpack的安装与使用"><a href="#webpack的安装与使用" class="headerlink" title="webpack的安装与使用"></a>webpack的安装与使用</h1><p>电脑早就已经安装好了node，所以只要 npm install 一下就好了</p>
<blockquote>
<p>npm install webpack -g</p>
</blockquote>
<p>然后初始化项目结构</p>
<blockquote>
<p>npm init</p>
</blockquote>
<p>在项目主目录中新建webpack.config.js,随便在网上找了一个完整的config示例，后续进行修改以满足自己的需求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack 配置示例</span></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> commonsPlugin = <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//插件项</span></span><br><span class="line">    plugins: [commonsPlugin],</span><br><span class="line">    <span class="comment">//页面入口文件配置</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        index : <span class="string">'./src/js/page/index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//入口文件输出配置</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'dist/js/page'</span>,</span><br><span class="line">        filename: <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        <span class="comment">//加载器配置</span></span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; test: <span class="regexp">/\.css$/</span>, loader: <span class="string">'style-loader!css-loader'</span> &#125;,</span><br><span class="line">            &#123; test: <span class="regexp">/\.js$/</span>, loader: <span class="string">'jsx-loader?harmony'</span> &#125;,</span><br><span class="line">            &#123; test: <span class="regexp">/\.scss$/</span>, loader: <span class="string">'style!css!sass?sourceMap'</span>&#125;,</span><br><span class="line">            &#123; test: <span class="regexp">/\.(png|jpg)$/</span>, loader: <span class="string">'url-loader?limit=8192'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//其它解决方案配置</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        root: <span class="string">'E:/github/flux-example/src'</span>, <span class="comment">//绝对路径</span></span><br><span class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>],</span><br><span class="line">        alias: &#123;</span><br><span class="line">            AppStore : <span class="string">'js/stores/AppStores.js'</span>,</span><br><span class="line">            ActionType : <span class="string">'js/actions/ActionType.js'</span>,</span><br><span class="line">            AppAction : <span class="string">'js/actions/AppAction.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。</li>
<li>entry 是页面入口文件配置，output 是对应输出项配置（即入口文件最终要生成什么名字的文件、存放到哪里）</li>
<li>module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理</li>
<li>最后是 resolve 配置<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><h1 id="配置html-webpack-plugin"><a href="#配置html-webpack-plugin" class="headerlink" title="配置html-webpack-plugin"></a>配置html-webpack-plugin</h1></li>
</ol>
<p>html-webpack-plugin可以自动快速的生成html文件，就不用每次还得手动重复的去建立html文件了。<br>安装</p>
<blockquote>
<p>npm install html-webpack-plugin –save-dev</p>
</blockquote>
<p>然后修改config</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlwebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">''</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="配置webpack-dev-server"><a href="#配置webpack-dev-server" class="headerlink" title="配置webpack-dev-server"></a>配置webpack-dev-server</h1><p>webpack-dev-server可以建立一个sever，监控文件的变化，实现页面自动刷新，所以开发的时候不需要手动刷新便可以看到改动的效果。<br>安装</p>
<blockquote>
<p>npm install webpack-dev-server –save-dev</p>
</blockquote>
<p>然后修改config进行配置<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> module.exports = &#123;</span><br><span class="line">  ....</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    hot: true,</span><br><span class="line">    inline: true,</span><br><span class="line">    progress: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再package.json里面配置一下运行的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;webpack-dev-server --hot --inline&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>在项目根目录下输入</p>
<blockquote>
<p>npm start</p>
</blockquote>
<p>就可以启动sever，在浏览器中打开localhost:8080就可以看到页面，接下来只要修改文件页面就会自动刷新了。</p>
<h1 id="配置loaders"><a href="#配置loaders" class="headerlink" title="配置loaders"></a>配置loaders</h1><h1 id="css-scss"><a href="#css-scss" class="headerlink" title="css,scss"></a>css,scss</h1><p>处理css需要两种loader，css-loader 和 style-loader，css-loader会遍历css文件，找到所有的url(…)并且处理。style-loader会把所有的样式插入页面的一个style tag中。.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理。<br>安装</p>
<blockquote>
<p>npm install css-loader style-loader sass-loader –save-dev</p>
</blockquote>
<h1 id="es6和jsx"><a href="#es6和jsx" class="headerlink" title="es6和jsx"></a>es6和jsx</h1><p>es6的语法支持和jsx文件可以通过bable进行编译处理<br>安装</p>
<blockquote>
<p>npm install babel-loader babel-preset-es2015 –save-dev</p>
</blockquote>
<h1 id="处理图片和其他静态文件"><a href="#处理图片和其他静态文件" class="headerlink" title="处理图片和其他静态文件"></a>处理图片和其他静态文件</h1><p>url-loader可以处理静态资源，根据需求将图片自动转成base64编码的，可以减轻很多的网络请求。<br>安装</p>
<blockquote>
<p>npm install url-loader –save-dev</p>
</blockquote>
<p>最终config文件中的module.loader配置是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">            //.css 文件使用 style-loader 和 css-loader 来处理</span><br><span class="line">            &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;,</span><br><span class="line">            //.js 文件使用 jsx-loader 来编译处理</span><br><span class="line">            &#123; test: /\.jsx?$/, loader: &apos;babel&apos;,include: APP_PATH, query: &#123; presets: [&apos;es2015&apos;] &#125; &#125;,</span><br><span class="line">            //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span><br><span class="line">            &#123; test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;&#125;,</span><br><span class="line">            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span><br><span class="line">            &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<h1 id="独立打包css"><a href="#独立打包css" class="headerlink" title="独立打包css"></a>独立打包css</h1><p>希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候可以使用 extract-text-webpack-plugin</p>
<blockquote>
<p>npm install extract-text-webpack-plugin –save-dev</p>
</blockquote>
<p>在config中设置一下插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);</span><br><span class="line">    var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        plugins: [commonsPlugin, new ExtractTextPlugin(&quot;[name].css&quot;)],</span><br><span class="line">        entry: &#123;</span><br><span class="line">        //...省略其它配置</span><br></pre></td></tr></table></figure></p>
<p>大致是完成了，接下来应该会学习一些插件的更多用法</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第一篇文章]]></title>
      <url>http://yoursite.com/2016/06/27/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<p><em>第一次想要搭建一个blog不知道是几年之前了，自己搞过服务器用webpy搭建过一个简易的，也在csdn开通过，但都只是三分钟热度，并没有在上面发表过什么东西，肚子里没几滴墨水，大学几年也浑浑噩噩，没学到什么东西。
</em>github也注册很久了，然而现在前端水平也只属于入门水平，并没有什么满意的项目推送到仓库。之前也有弄了一下gitpage，但是感觉并不方便，写博客的计划就又搁置了。知道最近发现hexo，而现在更换上班地点后到家比较早了，便又开始试了一下，作为一个前端，在发现页面主题和颜色可以自己编写之后又便根本停不下来了，折腾了半天之后，终于成了现在这个样子，虽然还需继续完善，但勉强也能看得下去了。<br>*毕业两年，作为前端工作也快满一年了，也逐渐开始深入学习，学习过程就在此记录吧。</p>
]]></content>
    </entry>
    
  
  
</search>
